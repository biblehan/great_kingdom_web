<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>그레이트 킹덤 - 이세돌의 위즈스톤</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            min-height: 100vh;
            padding: 10px;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .game-container {
            max-width: 600px;
            margin: 0 auto;
            padding: 0 5px;
        }

        .game-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .game-header h1 {
            font-size: 2em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 5px;
        }

        .game-header .subtitle {
            font-size: 1.1em;
            color: #ecf0f1;
            opacity: 0.8;
        }

        /* 난이도 선택 화면 */
        .difficulty-screen {
            background: rgba(255,255,255,0.15);
            padding: 30px 20px;
            border-radius: 15px;
            text-align: center;
            border: 2px solid rgba(255,255,255,0.2);
            margin-bottom: 20px;
        }

        .difficulty-screen h2 {
            color: #f39c12;
            margin-bottom: 20px;
            font-size: 1.4em;
        }

        .difficulty-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin-bottom: 20px;
            max-width: 350px;
            margin-left: auto;
            margin-right: auto;
        }

        .difficulty-btn {
            background: rgba(255,255,255,0.2);
            color: white;
            border: 2px solid rgba(255,255,255,0.3);
            padding: 15px 10px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.3s ease;
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .difficulty-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.05);
        }

        .difficulty-btn.selected {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            border-color: #fff;
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
        }

        .difficulty-info {
            font-size: 16px;
            color: #ecf0f1;
            margin-bottom: 25px;
            min-height: 25px;
            font-weight: 500;
        }

        .start-btn {
            background: linear-gradient(135deg, #27ae60, #229954);
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .start-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(39, 174, 96, 0.4);
        }

        /* 게임 화면 */
        .game-screen {
            display: none;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            gap: 10px;
        }

        .player-info, .computer-info {
            background: rgba(255,255,255,0.1);
            padding: 10px;
            border-radius: 8px;
            flex: 1;
            text-align: center;
            font-size: 0.9em;
        }

        .player-info {
            border-left: 4px solid #3498db;
        }

        .computer-info {
            border-left: 4px solid #e74c3c;
        }

        .score-display {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
        }

        .score-value {
            font-size: 1.2em;
            font-weight: bold;
        }

        .game-status {
            text-align: center;
            font-size: 1em;
            margin: 10px 0;
            padding: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
        }

        .game-board {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-gap: 1px;
            background: #2c3e50;
            padding: 5px;
            border-radius: 8px;
            margin: 15px auto;
            max-width: 90vw;
            width: 100%;
            aspect-ratio: 1;
        }

        .intersection {
            background: #34495e;
            border: 1px solid #2c3e50;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            min-height: 30px;
            touch-action: manipulation;
        }

        .intersection:hover {
            background: #3d566e;
        }

        .intersection:active {
            background: #4a6fa5;
            transform: scale(0.95);
        }

        .intersection.last-move {
            background: #f39c12 !important;
            box-shadow: 0 0 10px rgba(243, 156, 18, 0.6);
        }

        .stone {
            width: 85%;
            height: 85%;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.7em;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            pointer-events: none;
        }

        .stone.player {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .stone.computer {
            background: linear-gradient(135deg, #e67e22, #d35400);
            color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .stone.neutral {
            background: linear-gradient(135deg, #95a5a6, #7f8c8d);
            color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .btn {
            background: linear-gradient(135deg, #8e44ad, #9b59b6);
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            touch-action: manipulation;
            -webkit-appearance: none;
            min-height: 44px;
            min-width: 60px;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(0,0,0,0.3);
        }

        .btn:active {
            transform: translateY(0);
            box-shadow: 0 1px 5px rgba(0,0,0,0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* 게임 종료 결과 화면 */
        .game-result {
            display: none;
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 15px;
            margin-top: 20px;
            text-align: center;
        }

        .game-result.show {
            display: block;
        }

        .result-title {
            font-size: 1.8em;
            margin-bottom: 15px;
            font-weight: bold;
        }

        .result-title.win {
            color: #27ae60;
        }

        .result-title.lose {
            color: #e74c3c;
        }

        .result-message {
            font-size: 1.1em;
            margin-bottom: 20px;
            line-height: 1.4;
        }

        .final-board {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-gap: 1px;
            background: #2c3e50;
            padding: 5px;
            border-radius: 8px;
            margin: 20px auto;
            max-width: 300px;
            aspect-ratio: 1;
        }

        .final-board .intersection {
            min-height: 20px;
            cursor: default;
        }

        .final-board .stone {
            font-size: 0.5em;
        }

        .result-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }

        .result-btn {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .result-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.4);
        }

        /* 모바일 최적화 */
        @media (max-width: 480px) {
            .game-header h1 {
                font-size: 1.7em;
            }
            
            .difficulty-grid {
                max-width: 280px;
                gap: 8px;
            }
            
            .difficulty-btn {
                padding: 12px 8px;
                font-size: 16px;
            }

            .final-board {
                max-width: 250px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <h1>🏰 그레이트 킹덤</h1>
            <div class="subtitle">이세돌의 위즈스톤</div>
        </div>

        <!-- 난이도 선택 화면 -->
        <div class="difficulty-screen" id="difficultyScreen">
            <h2>🎯 난이도 선택</h2>
            <div class="difficulty-grid">
                <button class="difficulty-btn" data-level="1">1</button>
                <button class="difficulty-btn" data-level="2">2</button>
                <button class="difficulty-btn" data-level="3">3</button>
                <button class="difficulty-btn" data-level="4">4</button>
                <button class="difficulty-btn selected" data-level="5">5</button>
                <button class="difficulty-btn" data-level="6">6</button>
                <button class="difficulty-btn" data-level="7">7</button>
                <button class="difficulty-btn" data-level="8">8</button>
                <button class="difficulty-btn" data-level="9">9</button>
                <button class="difficulty-btn" data-level="10">10</button>
            </div>
            <div class="difficulty-info" id="difficultyInfo">
                중간 난이도 - 적당한 도전
            </div>
            <button class="start-btn" id="startGame">게임 시작</button>
        </div>

        <!-- 게임 화면 -->
        <div class="game-screen" id="gameScreen">
            <div class="game-info">
                <div class="player-info">
                    <h3>🔵 당신 (파란색)</h3>
                    <div class="score-display">
                        <div>영토: <span class="score-value" id="playerTerritory">0</span></div>
                        <div>돌: <span class="score-value" id="playerStones">40</span></div>
                    </div>
                </div>
                <div class="computer-info">
                    <h3>🟠 컴퓨터 (주황색)</h3>
                    <div class="score-display">
                        <div>영토: <span class="score-value" id="computerTerritory">0</span></div>
                        <div>돌: <span class="score-value" id="computerStones">40</span></div>
                    </div>
                </div>
            </div>

            <div class="game-status" id="gameStatus">게임 준비 중...</div>

            <div class="game-board" id="gameBoard"></div>

            <div class="controls">
                <button class="btn" id="passBtn">패스</button>
                <button class="btn" id="newGameBtn">새 게임</button>
            </div>

            <!-- 게임 결과 화면 -->
            <div class="game-result" id="gameResult">
                <div class="result-title" id="resultTitle">게임 종료</div>
                <div class="result-message" id="resultMessage"></div>
                <div class="final-board" id="finalBoard"></div>
                <div class="result-controls">
                    <button class="result-btn" id="newGameFromResult">새 게임</button>
                    <button class="result-btn" id="reviewGame">복기하기</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let selectedDifficulty = 5;
        let gameInstance = null;

        document.addEventListener('DOMContentLoaded', function() {
            initializeDifficultySelector();
        });

        function initializeDifficultySelector() {
            const difficultyButtons = document.querySelectorAll('.difficulty-btn');
            difficultyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.difficulty-btn').forEach(b => {
                        b.classList.remove('selected');
                    });
                    
                    this.classList.add('selected');
                    selectedDifficulty = parseInt(this.dataset.level);
                    updateDifficultyDescription();
                });
            });

            document.getElementById('startGame').addEventListener('click', function() {
                startNewGame();
            });

            document.getElementById('passBtn').addEventListener('click', function() {
                if (gameInstance && gameInstance.currentPlayer === 'player' && !gameInstance.gameEnded) {
                    gameInstance.pass();
                }
            });

            document.getElementById('newGameBtn').addEventListener('click', function() {
                backToMenu();
            });

            document.getElementById('newGameFromResult').addEventListener('click', function() {
                backToMenu();
            });

            document.getElementById('reviewGame').addEventListener('click', function() {
                if (gameInstance) {
                    gameInstance.startReview();
                }
            });

            document.getElementById('gameBoard').addEventListener('click', function(e) {
                if (e.target.classList.contains('intersection') && gameInstance && 
                    gameInstance.currentPlayer === 'player' && !gameInstance.gameEnded) {
                    const index = parseInt(e.target.dataset.index);
                    gameInstance.makeMove(index, 'player');
                }
            });

            updateDifficultyDescription();
        }

        function updateDifficultyDescription() {
            const descriptions = {
                1: "초보자 - AI가 거의 랜덤하게 움직입니다",
                2: "쉬움 - 기본적인 패턴만 사용합니다", 
                3: "약간 쉬움 - 간단한 전략을 사용합니다",
                4: "쉬운 편 - 공격과 방어를 조금 생각합니다",
                5: "중간 난이도 - 적당한 도전",
                6: "약간 어려움 - 영토 확장을 우선시합니다",
                7: "어려움 - 전략적 사고를 합니다",
                8: "상당히 어려움 - 고급 전술을 사용합니다",
                9: "매우 어려움 - 여러 수를 미리 계산합니다",
                10: "극한 난이도 - 프로 수준의 AI"
            };
            
            document.getElementById('difficultyInfo').textContent = descriptions[selectedDifficulty];
        }

        function startNewGame() {
            document.getElementById('difficultyScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';
            
            gameInstance = new GreatKingdomGame(selectedDifficulty);
        }

        function backToMenu() {
            document.getElementById('difficultyScreen').style.display = 'block';
            document.getElementById('gameScreen').style.display = 'none';
            gameInstance = null;
        }

        class GreatKingdomGame {
            constructor(difficulty) {
                this.difficulty = difficulty;
                this.board = Array(81).fill(null);
                this.currentPlayer = 'computer';
                this.playerStones = 40;
                this.computerStones = 40;
                this.consecutivePasses = 0;
                this.gameEnded = false;
                this.gameHistory = [];
                this.lastMove = null;
                this.reviewMode = false;
                this.reviewStep = 0;
                
                this.initializeGame();
            }

            initializeGame() {
                this.createBoard();
                this.placeNeutralStone();
                this.updateDisplay();
                
                document.getElementById('gameStatus').textContent = `난이도 ${this.difficulty} - 컴퓨터가 먼저 시작합니다...`;
                document.getElementById('gameResult').classList.remove('show');
                
                setTimeout(() => this.computerMove(), 1500);
            }

            createBoard() {
                const boardElement = document.getElementById('gameBoard');
                boardElement.innerHTML = '';

                for (let i = 0; i < 81; i++) {
                    const intersection = document.createElement('div');
                    intersection.className = 'intersection';
                    intersection.dataset.index = i;
                    boardElement.appendChild(intersection);
                }
            }

            placeNeutralStone() {
                this.board[40] = 'neutral';
                this.gameHistory.push({ move: 40, player: 'neutral', board: [...this.board] });
            }

            makeMove(index, player) {
                if (this.board[index] !== null || this.reviewMode) {
                    return false;
                }

                this.board[index] = player;
                this.consecutivePasses = 0;
                this.lastMove = index;

                if (player === 'player') {
                    this.playerStones--;
                } else {
                    this.computerStones--;
                }

                this.gameHistory.push({
                    move: index,
                    player: player,
                    board: [...this.board]
                });

                this.checkCaptures(player);
                this.updateDisplay();
                
                if (!this.gameEnded) {
                    this.switchPlayer();
                }
                
                return true;
            }

            checkCaptures(player) {
                const opponent = player === 'player' ? 'computer' : 'player';
                let capturedCount = 0;

                for (let i = 0; i < 81; i++) {
                    if (this.board[i] === opponent) {
                        const group = this.getGroup(i);
                        if (this.isCaptured(group)) {
                            group.forEach(index => {
                                this.board[index] = null;
                                capturedCount++;
                            });
                        }
                    }
                }

                if (capturedCount > 0) {
                    this.endGame(player, '포획 승리');
                }
            }

            getGroup(startIndex) {
                if (this.board[startIndex] === null) return [];
                
                const color = this.board[startIndex];
                const group = [];
                const visited = new Set();
                const stack = [startIndex];

                while (stack.length > 0) {
                    const index = stack.pop();
                    if (visited.has(index)) continue;
                    
                    visited.add(index);
                    if (this.board[index] === color) {
                        group.push(index);
                        
                        const neighbors = this.getNeighbors(index);
                        neighbors.forEach(neighbor => {
                            if (!visited.has(neighbor) && this.board[neighbor] === color) {
                                stack.push(neighbor);
                            }
                        });
                    }
                }

                return group;
            }

            isCaptured(group) {
                for (let index of group) {
                    const neighbors = this.getNeighbors(index);
                    for (let neighbor of neighbors) {
                        if (this.board[neighbor] === null) {
                            return false;
                        }
                    }
                }
                return true;
            }

            getNeighbors(index) {
                const neighbors = [];
                const row = Math.floor(index / 9);
                const col = index % 9;

                const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                
                directions.forEach(([dr, dc]) => {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    
                    if (newRow >= 0 && newRow < 9 && newCol >= 0 && newCol < 9) {
                        neighbors.push(newRow * 9 + newCol);
                    }
                });

                return neighbors;
            }

            computerMove() {
                if (this.gameEnded || this.reviewMode) return;

                const candidates = this.getValidMoves('computer');
                if (candidates.length === 0) {
                    this.pass();
                    return;
                }

                // 즉시 포획 가능한 수 우선
                for (let move of candidates) {
                    const tempBoard = [...this.board];
                    tempBoard[move] = 'computer';
                    
                    // 상대방 돌 포획 체크
                    for (let i = 0; i < 81; i++) {
                        if (tempBoard[i] === 'player') {
                            const group = this.getGroupFromBoard(tempBoard, i);
                            if (this.isGroupCaptured(tempBoard, group)) {
                                this.makeMove(move, 'computer');
                                return;
                            }
                        }
                    }
                }

                let chosenMove;

                // 난이도별 AI 전략
                if (this.difficulty <= 3) {
                    // 쉬운 난이도: 랜덤 + 약간 중앙 선호
                    if (Math.random() < 0.7) {
                        chosenMove = candidates[Math.floor(Math.random() * candidates.length)];
                    } else {
                        const centers = this.getCenterMoves(candidates);
                        chosenMove = centers.length ? centers[Math.floor(Math.random() * centers.length)]
                                                    : candidates[Math.floor(Math.random() * candidates.length)];
                    }
                } else {
                    // 고급 난이도: 최선의 수들 중에서 랜덤 선택
                    const scoredMoves = this.evaluateAllMoves(candidates);
                    
                    // 최고 점수와 비슷한 수들 찾기
                    const bestScore = scoredMoves[0].score;
                    const threshold = this.difficulty >= 8 ? 0.5 : 1.0;
                    const similarMoves = scoredMoves.filter(m => 
                        Math.abs(m.score - bestScore) <= threshold
                    );
                    
                    // 유사한 점수의 수들 중에서 랜덤 선택
                    if (similarMoves.length > 1) {
                        chosenMove = similarMoves[Math.floor(Math.random() * similarMoves.length)].move;
                    } else {
                        chosenMove = scoredMoves[0].move;
                    }
                }

                this.makeMove(chosenMove, 'computer');
            }

            evaluateAllMoves(candidates) {
                const scored = candidates.map(mv => {
                    let score = this.evaluateMove(mv, 'computer');
                    
                    // 랜덤 노이즈 추가 (동점 상황 방지)
                    score += (Math.random() - 0.5) * 0.2;
                    
                    return { move: mv, score: score };
                });
                
                return scored.sort((a, b) => b.score - a.score);
            }

            getValidMoves(player) {
                const moves = [];
                for (let i = 0; i < 81; i++) {
                    if (this.board[i] === null) {
                        moves.push(i);
                    }
                }
                return moves;
            }

            getCenterMoves(moves) {
                return moves.filter(move => {
                    const row = Math.floor(move / 9);
                    const col = move % 9;
                    return row >= 3 && row <= 5 && col >= 3 && col <= 5;
                });
            }

            evaluateMove(move, player) {
                let score = 0;
                const row = Math.floor(move / 9);
                const col = move % 9;
                
                // 중심부 선호
                const centerDistance = Math.abs(row - 4) + Math.abs(col - 4);
                score += (8 - centerDistance) * 0.5;
                
                // 자신의 돌과 연결성
                const neighbors = this.getNeighbors(move);
                const friendlyNeighbors = neighbors.filter(n => this.board[n] === player).length;
                score += friendlyNeighbors * 3;
                
                // 상대방 돌 근처 (공격 기회)
                const enemyNeighbors = neighbors.filter(n => this.board[n] === (player === 'player' ? 'computer' : 'player')).length;
                score += enemyNeighbors * 2;
                
                return score;
            }

            getGroupFromBoard(board, startIndex) {
                if (board[startIndex] === null) return [];
                
                const color = board[startIndex];
                const group = [];
                const visited = new Set();
                const stack = [startIndex];

                while (stack.length > 0) {
                    const index = stack.pop();
                    if (visited.has(index)) continue;
                    
                    visited.add(index);
                    if (board[index] === color) {
                        group.push(index);
                        
                        const neighbors = this.getNeighbors(index);
                        neighbors.forEach(neighbor => {
                            if (!visited.has(neighbor) && board[neighbor] === color) {
                                stack.push(neighbor);
                            }
                        });
                    }
                }

                return group;
            }

            isGroupCaptured(board, group) {
                for (let index of group) {
                    const neighbors = this.getNeighbors(index);
                    for (let neighbor of neighbors) {
                        if (board[neighbor] === null) {
                            return false;
                        }
                    }
                }
                return true;
            }

            pass() {
                this.consecutivePasses++;
                
                if (this.consecutivePasses >= 2) {
                    this.calculateScore(true);
                    return;
                }

                this.switchPlayer();
            }

            switchPlayer() {
                if (this.gameEnded || this.reviewMode) return;
                
                this.currentPlayer = this.currentPlayer === 'player' ? 'computer' : 'player';
                this.updateDisplay();

                if (this.currentPlayer === 'computer') {
                    setTimeout(() => this.computerMove(), 800);
                }
            }

            calculateScore(showResult = true) {
			    let playerScore = 0;
			    let computerScore = 0;
			
			    for (let i = 0; i < 81; i++) {
			        if (this.board[i] === 'player') {
			            playerScore++;
			        } else if (this.board[i] === 'computer') {
			            computerScore++;
			        }
			    }
			
			    let winner;
			    if (computerScore - playerScore >= 3) {
			        winner = 'computer';
			    } else {
			        winner = 'player';
			    }
			
			    if (showResult) {
			        this.endGame(winner, '점수');
			    }
			
			    return { playerScore, computerScore, winner };
			}
	
			endGame(winner, reason) {
			    this.gameEnded = true;
			    const { playerScore, computerScore } = this.calculateScore(false);
			    
			    let title = winner === 'player' ? '승리!' : '패배!';
			    let message = `최종 점수: 당신 ${playerScore}점, 컴퓨터 ${computerScore}점`;
			    
			    if (reason === '포획 승리') {
			        message = `${winner === 'player' ? '당신이' : '컴퓨터가'} 상대방 돌을 포획하여 승리했습니다!`;
			    }
			
			    this.showGameResult(title, message, winner);
			}
			
			showGameResult(title, message, winner) {
			    const resultElement = document.getElementById('gameResult');
			    const titleElement = document.getElementById('resultTitle');
			    const messageElement = document.getElementById('resultMessage');
			    
			    titleElement.textContent = title;
			    titleElement.className = `result-title ${winner === 'player' ? 'win' : 'lose'}`;
			    messageElement.textContent = message;
			    
			    this.createFinalBoard();
			    resultElement.classList.add('show');
			}
			
			createFinalBoard() {
			    const finalBoard = document.getElementById('finalBoard');
			    finalBoard.innerHTML = '';
			
			    for (let i = 0; i < 81; i++) {
			        const intersection = document.createElement('div');
			        intersection.className = 'intersection';
			        
			        if (this.board[i] !== null) {
			            const stone = document.createElement('div');
			            stone.className = `stone ${this.board[i]}`;
			            intersection.appendChild(stone);
			        }
			        
			        if (i === this.lastMove) {
			            intersection.classList.add('last-move');
			        }
			        
			        finalBoard.appendChild(intersection);
			    }
			}
			
			startReview() {
			    this.reviewMode = true;
			    this.reviewStep = 0;
			    document.getElementById('gameResult').classList.remove('show');
			    document.getElementById('gameStatus').textContent = '복기 모드 - 클릭하여 다음 수를 확인하세요';
			    
			    // 초기 상태로 보드 리셋
			    this.board = Array(81).fill(null);
			    this.lastMove = null;
			    this.updateDisplay();
			    this.showReviewStep();
			}
			
			showReviewStep() {
			    if (this.reviewStep < this.gameHistory.length) {
			        const step = this.gameHistory[this.reviewStep];
			        this.board = [...step.board];
			        this.lastMove = step.move;
			        this.updateDisplay();
			        
			        const playerName = step.player === 'player' ? '당신' : 
			                         step.player === 'computer' ? '컴퓨터' : '중립';
			        document.getElementById('gameStatus').textContent = 
			            `${this.reviewStep + 1}/${this.gameHistory.length}: ${playerName}이 ${this.indexToCoord(step.move)}에 착수`;
			        
			        this.reviewStep++;
			        
			        // 자동으로 다음 수 보여주기
			        setTimeout(() => {
			            if (this.reviewMode && this.reviewStep < this.gameHistory.length) {
			                this.showReviewStep();
			            } else if (this.reviewMode) {
			                document.getElementById('gameStatus').textContent = '복기 완료 - 새 게임을 시작하세요';
			                this.reviewMode = false;
			            }
			        }, 1500);
			    }
			}
		
			indexToCoord(index) {
			    const row = Math.floor(index / 9);
			    const col = index % 9;
			    const letters = 'ABCDEFGHI';
			    return letters[col] + (row + 1);
			}
			
			updateDisplay() {
			    // 보드 업데이트
			    for (let i = 0; i < 81; i++) {
			        const element = document.querySelector(`[data-index="${i}"]`);
			        if (element) {
			            element.innerHTML = '';
			            element.classList.remove('last-move');
			            
			            if (this.board[i] !== null) {
			                const stone = document.createElement('div');
			                stone.className = `stone ${this.board[i]}`;
			                element.appendChild(stone);
			            }
			            
			            // 마지막 착수 하이라이트
			            if (i === this.lastMove && !this.reviewMode) {
			                element.classList.add('last-move');
			            }
			        }
			    }
			
			    // 정보 업데이트
			    document.getElementById('playerStones').textContent = this.playerStones;
			    document.getElementById('computerStones').textContent = this.computerStones;
			
			    const { playerScore, computerScore } = this.calculateScore(false);
			    document.getElementById('playerTerritory').textContent = playerScore;
			    document.getElementById('computerTerritory').textContent = computerScore;
			
			    // 상태 표시
			    if (!this.gameEnded && !this.reviewMode) {
			        const statusText = this.currentPlayer === 'player' ? 
			            '당신의 차례입니다 (파란색 돌)' : 
			            '컴퓨터가 생각 중입니다...';
			        document.getElementById('gameStatus').textContent = statusText;
			    }
			
			    // 버튼 상태
			    const passBtn = document.getElementById('passBtn');
			    if (passBtn) {
			        passBtn.disabled = this.currentPlayer !== 'player' || this.gameEnded || this.reviewMode;
			    }
			}
		}
    </script>
</body>
</html>
