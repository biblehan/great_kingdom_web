<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ê·¸ë ˆì´íŠ¸ í‚¹ë¤ - ì´ì„¸ëŒì˜ ìœ„ì¦ˆìŠ¤í†¤</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }

        .game-container {
            max-width: 800px;
            margin: 0 auto;
        }

        .game-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .game-header h1 {
            font-size: 2.2em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 5px;
        }

        .game-header .subtitle {
            font-size: 1.1em;
            color: #ecf0f1;
            opacity: 0.8;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            gap: 20px;
        }

        .player-info, .computer-info {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            flex: 1;
            text-align: center;
        }

        .player-info {
            border-left: 4px solid #3498db;
        }

        .computer-info {
            border-left: 4px solid #e74c3c;
        }

        .game-board {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-gap: 1px;
            background: #2c3e50;
            padding: 10px;
            border-radius: 10px;
            margin: 20px auto;
            max-width: 500px;
            aspect-ratio: 1;
        }

        .intersection {
            background: #34495e;
            border: 1px solid #2c3e50;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .intersection:hover {
            background: #3d566e;
        }

        .stone {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.8em;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .stone.player {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .stone.computer {
            background: linear-gradient(135deg, #e67e22, #d35400);
            color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .stone.neutral {
            background: linear-gradient(135deg, #95a5a6, #7f8c8d);
            color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .captured {
            animation: captureAnimation 0.5s ease-out forwards;
        }

        @keyframes captureAnimation {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.7; }
            100% { transform: scale(0); opacity: 0; }
        }

        .territory {
            background: rgba(255, 255, 255, 0.2) !important;
            border: 2px dashed #ecf0f1;
        }

        .territory.player-territory {
            background: rgba(52, 152, 219, 0.3) !important;
            border: 2px dashed #3498db;
        }

        .territory.computer-territory {
            background: rgba(231, 76, 60, 0.3) !important;
            border: 2px dashed #e74c3c;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
        }

        .btn {
            background: linear-gradient(135deg, #8e44ad, #9b59b6);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .game-status {
            text-align: center;
            font-size: 1.2em;
            margin: 15px 0;
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
        }

        .game-log {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 10px;
            max-height: 150px;
            overflow-y: auto;
            margin-top: 20px;
        }

        .game-log h3 {
            margin-bottom: 10px;
            color: #f39c12;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 3px 0;
            font-size: 0.9em;
        }

        .game-over-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-content {
            background: linear-gradient(135deg, #8e44ad, #9b59b6);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 400px;
        }

        .score-display {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
        }

        .score-item {
            text-align: center;
        }

        .score-value {
            font-size: 1.5em;
            font-weight: bold;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <h1>ğŸ° ê·¸ë ˆì´íŠ¸ í‚¹ë¤</h1>
            <div class="subtitle">ì´ì„¸ëŒì˜ ìœ„ì¦ˆìŠ¤í†¤</div>
        </div>

        <div class="game-info">
            <div class="player-info">
                <h3>ğŸ”µ ë‹¹ì‹  (íŒŒë€ìƒ‰)</h3>
                <div class="score-display">
                    <div class="score-item">
                        <div>ì˜í† </div>
                        <div class="score-value" id="playerTerritory">0</div>
                    </div>
                    <div class="score-item">
                        <div>ëŒ ìˆ˜</div>
                        <div class="score-value" id="playerStones">40</div>
                    </div>
                </div>
            </div>
            <div class="computer-info">
                <h3>ğŸŸ  ì»´í“¨í„° (ì£¼í™©ìƒ‰)</h3>
                <div class="score-display">
                    <div class="score-item">
                        <div>ì˜í† </div>
                        <div class="score-value" id="computerTerritory">0</div>
                    </div>
                    <div class="score-item">
                        <div>ëŒ ìˆ˜</div>
                        <div class="score-value" id="computerStones">40</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="game-status" id="gameStatus">ë‹¹ì‹ ì˜ ì°¨ë¡€ì…ë‹ˆë‹¤ (íŒŒë€ìƒ‰ ëŒ)</div>

        <div class="game-board" id="gameBoard"></div>

        <div class="controls">
            <button class="btn" id="passBtn">íŒ¨ìŠ¤</button>
            <button class="btn" id="calculateBtn">ì ìˆ˜ ê³„ì‚°</button>
            <button class="btn" id="resetBtn">ìƒˆ ê²Œì„</button>
        </div>

        <div class="game-log">
            <h3>ğŸ“‹ ê²Œì„ ë¡œê·¸</h3>
            <div id="gameLogContent"></div>
        </div>
    </div>

    <div class="game-over-modal" id="gameOverModal">
        <div class="modal-content">
            <h2 id="gameOverTitle"></h2>
            <p id="gameOverMessage"></p>
            <button class="btn" onclick="resetGame()">ë‹¤ì‹œ ì‹œì‘</button>
        </div>
    </div>

    <script>
        class GreatKingdomGame {
            constructor() {
                this.board = Array(81).fill(null); // 9x9 ë³´ë“œ
                this.currentPlayer = 'player'; // playerëŠ” íŒŒë€ìƒ‰(í›„ê³µ), computerëŠ” ì£¼í™©ìƒ‰(ì„ ê³µ)
                this.playerStones = 40;
                this.computerStones = 40;
                this.consecutivePasses = 0;
                this.gameEnded = false;
                this.gameLog = [];
                
                this.initializeGame();
            }

            initializeGame() {
                this.createBoard();
                this.placeNeutralStone();
                this.updateDisplay();
                this.addEventListeners();
                this.logMessage("ê²Œì„ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤!");
                this.logMessage("ì¤‘ì•™ì— ì¤‘ë¦½ ëŒì´ ë°°ì¹˜ë˜ì—ˆìŠµë‹ˆë‹¤.");
                this.logMessage("ì»´í“¨í„°ê°€ ì„ ê³µ(ì£¼í™©ìƒ‰)ì…ë‹ˆë‹¤.");
                
                // ì»´í“¨í„°ê°€ ì„ ê³µì´ë¯€ë¡œ ì»´í“¨í„° í„´ìœ¼ë¡œ ì‹œì‘
                this.currentPlayer = 'computer';
                setTimeout(() => this.computerMove(), 1000);
            }

            createBoard() {
                const boardElement = document.getElementById('gameBoard');
                boardElement.innerHTML = '';

                for (let i = 0; i < 81; i++) {
                    const intersection = document.createElement('div');
                    intersection.className = 'intersection';
                    intersection.dataset.index = i;
                    boardElement.appendChild(intersection);
                }
            }

            placeNeutralStone() {
                // ì¤‘ì•™(4,4 = ì¸ë±ìŠ¤ 40)ì— ì¤‘ë¦½ ëŒ ë°°ì¹˜
                this.board[40] = 'neutral';
            }

            addEventListeners() {
                // í„°ì¹˜ ì´ë²¤íŠ¸ ì§€ì› ì¶”ê°€
                document.getElementById('gameBoard').addEventListener('click', (e) => {
                    if (e.target.classList.contains('intersection') && this.currentPlayer === 'player' && !this.gameEnded) {
                        const index = parseInt(e.target.dataset.index);
                        this.makeMove(index, 'player');
                    }
                });

                // í„°ì¹˜ ì´ë²¤íŠ¸ë¡œë„ ë™ì‘í•˜ë„ë¡
                document.getElementById('gameBoard').addEventListener('touchend', (e) => {
                    e.preventDefault();
                    if (e.target.classList.contains('intersection') && this.currentPlayer === 'player' && !this.gameEnded) {
                        const index = parseInt(e.target.dataset.index);
                        this.makeMove(index, 'player');
                    }
                });

                document.getElementById('passBtn').addEventListener('click', () => {
                    if (this.currentPlayer === 'player' && !this.gameEnded) {
                        this.pass();
                    }
                });

                document.getElementById('calculateBtn').addEventListener('click', () => {
                    this.calculateScore(true);
                });

                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.resetGame();
                });
            }

            makeMove(index, player) {
                if (this.board[index] !== null) {
                    return false; // ì´ë¯¸ ëŒì´ ìˆìŒ
                }

                // ìƒëŒ€ë°© ì™„ì„±ëœ ì˜í† ì—ëŠ” ë‘˜ ìˆ˜ ì—†ìŒ ê·œì¹™ ì²´í¬
                if (this.isInOpponentTerritory(index, player)) {
                    this.logMessage("ìƒëŒ€ë°©ì˜ ì˜í† ì—ëŠ” ëŒì„ ë‘˜ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!");
                    return false;
                }

                this.board[index] = player;
                this.consecutivePasses = 0;

                if (player === 'player') {
                    this.playerStones--;
                } else {
                    this.computerStones--;
                }

                this.logMessage(`${player === 'player' ? 'ë‹¹ì‹ ì´' : 'ì»´í“¨í„°ê°€'} ${this.indexToCoord(index)}ì— ëŒì„ ë†“ì•˜ìŠµë‹ˆë‹¤.`);

                // ìƒëŒ€ë°© ëŒ í¬íš ì²´í¬
                this.checkCaptures(player);

                this.updateDisplay();
                this.switchPlayer();
                return true;
            }

            isInOpponentTerritory(index, player) {
                // ì„ì‹œë¡œ ëŒì„ ë†“ê³  ì˜ì—­ì„ ì²´í¬
                const originalBoard = [...this.board];
                this.board[index] = player;
                
                const territories = this.calculateTerritories();
                const opponentPlayer = player === 'player' ? 'computer' : 'player';
                
                // ì›ë˜ ë³´ë“œ ìƒíƒœë¡œ ë³µì›
                this.board = originalBoard;
                
                // ìƒëŒ€ë°© ì˜í† ì— í¬í•¨ë˜ëŠ”ì§€ ì²´í¬
                for (let territory of territories) {
                    if (territory.owner === opponentPlayer && territory.points.includes(index)) {
                        return true;
                    }
                }
                return false;
            }

            checkCaptures(player) {
                const opponent = player === 'player' ? 'computer' : 'player';
                let capturedCount = 0;

                for (let i = 0; i < 81; i++) {
                    if (this.board[i] === opponent) {
                        const group = this.getGroup(i);
                        if (this.isCaptured(group)) {
                            // ê·¸ë£¹ í¬íš
                            group.forEach(index => {
                                this.board[index] = null;
                                capturedCount++;
                                
                                // í¬íš ì• ë‹ˆë©”ì´ì…˜
                                const element = document.querySelector(`[data-index="${index}"]`);
                                const stone = element.querySelector('.stone');
                                if (stone) {
                                    stone.classList.add('captured');
                                    setTimeout(() => {
                                        element.innerHTML = '';
                                    }, 500);
                                }
                            });
                        }
                    }
                }

                if (capturedCount > 0) {
                    this.logMessage(`${capturedCount}ê°œì˜ ${opponent === 'player' ? 'íŒŒë€ìƒ‰' : 'ì£¼í™©ìƒ‰'} ëŒì„ í¬íší–ˆìŠµë‹ˆë‹¤!`);
                    
                    // ìƒëŒ€ë°© ëŒì„ í•˜ë‚˜ë¼ë„ í¬íší•˜ë©´ ì¦‰ì‹œ ìŠ¹ë¦¬
                    if (capturedCount > 0) {
                        this.endGame(player, 'í¬íš ìŠ¹ë¦¬');
                        return;
                    }
                }
            }

            getGroup(startIndex) {
                if (this.board[startIndex] === null) return [];
                
                const color = this.board[startIndex];
                const group = [];
                const visited = new Set();
                const stack = [startIndex];

                while (stack.length > 0) {
                    const index = stack.pop();
                    if (visited.has(index)) continue;
                    
                    visited.add(index);
                    if (this.board[index] === color) {
                        group.push(index);
                        
                        // ì¸ì ‘í•œ ìœ„ì¹˜ ì²´í¬
                        const neighbors = this.getNeighbors(index);
                        neighbors.forEach(neighbor => {
                            if (!visited.has(neighbor) && this.board[neighbor] === color) {
                                stack.push(neighbor);
                            }
                        });
                    }
                }

                return group;
            }

            isCaptured(group) {
                // ê·¸ë£¹ì´ ì™„ì „íˆ ë‘˜ëŸ¬ì‹¸ì—¬ ìˆëŠ”ì§€ ì²´í¬
                for (let index of group) {
                    const neighbors = this.getNeighbors(index);
                    for (let neighbor of neighbors) {
                        if (this.board[neighbor] === null) {
                            return false; // ë¹ˆ ê³µê°„ì´ ìˆìœ¼ë©´ í¬íšë˜ì§€ ì•ŠìŒ
                        }
                    }
                }
                return true;
            }

            getNeighbors(index) {
                const neighbors = [];
                const row = Math.floor(index / 9);
                const col = index % 9;

                // ìƒí•˜ì¢Œìš°ë§Œ ì²´í¬ (ëŒ€ê°ì„  ì œì™¸)
                const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                
                directions.forEach(([dr, dc]) => {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    
                    if (newRow >= 0 && newRow < 9 && newCol >= 0 && newCol < 9) {
                        neighbors.push(newRow * 9 + newCol);
                    }
                });

                return neighbors;
            }

            computerMove() {
                if (this.gameEnded) return;

                // ê°„ë‹¨í•œ AI: ëœë¤í•˜ê²Œ ìœ íš¨í•œ ìœ„ì¹˜ ì„ íƒ
                const validMoves = [];
                for (let i = 0; i < 81; i++) {
                    if (this.board[i] === null && !this.isInOpponentTerritory(i, 'computer')) {
                        validMoves.push(i);
                    }
                }

                if (validMoves.length === 0) {
                    this.pass();
                    return;
                }

                const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];
                this.makeMove(randomMove, 'computer');
            }

            pass() {
                this.consecutivePasses++;
                this.logMessage(`${this.currentPlayer === 'player' ? 'ë‹¹ì‹ ì´' : 'ì»´í“¨í„°ê°€'} íŒ¨ìŠ¤í–ˆìŠµë‹ˆë‹¤.`);
                
                if (this.consecutivePasses >= 2) {
                    this.calculateScore(false);
                    return;
                }

                this.switchPlayer();
            }

            switchPlayer() {
                if (this.gameEnded) return;
                
                this.currentPlayer = this.currentPlayer === 'player' ? 'computer' : 'player';
                this.updateDisplay();

                if (this.currentPlayer === 'computer') {
                    setTimeout(() => this.computerMove(), 1000);
                }
            }

            calculateTerritories() {
                const territories = [];
                const visited = new Set();

                for (let i = 0; i < 81; i++) {
                    if (this.board[i] === null && !visited.has(i)) {
                        const territory = this.floodFill(i, visited);
                        if (territory.points.length > 0) {
                            territories.push(territory);
                        }
                    }
                }

                return territories;
            }

            floodFill(startIndex, visited) {
                const territory = {
                    points: [],
                    owner: null,
                    surroundingColors: new Set()
                };

                const stack = [startIndex];
                const territoryPoints = new Set();

                while (stack.length > 0) {
                    const index = stack.pop();
                    if (visited.has(index) || territoryPoints.has(index)) continue;
                    if (this.board[index] !== null) continue;

                    territoryPoints.add(index);
                    visited.add(index);
                    territory.points.push(index);

                    const neighbors = this.getNeighbors(index);
                    neighbors.forEach(neighbor => {
                        if (this.board[neighbor] === null && !territoryPoints.has(neighbor)) {
                            stack.push(neighbor);
                        } else if (this.board[neighbor] !== null) {
                            territory.surroundingColors.add(this.board[neighbor]);
                        }
                    });

                    // ê°€ì¥ìë¦¬ë„ ì²´í¬
                    const row = Math.floor(index / 9);
                    const col = index % 9;
                    if (row === 0 || row === 8 || col === 0 || col === 8) {
                        territory.surroundingColors.add('edge');
                    }
                }

                // ì˜í†  ì†Œìœ ê¶Œ ê²°ì •
                const colors = Array.from(territory.surroundingColors);
                if (colors.length === 1 && colors[0] !== 'neutral') {
                    territory.owner = colors[0] === 'edge' ? null : colors[0];
                } else if (colors.length === 2 && colors.includes('edge')) {
                    const nonEdgeColor = colors.find(c => c !== 'edge');
                    if (nonEdgeColor !== 'neutral') {
                        territory.owner = nonEdgeColor;
                    }
                }

                return territory;
            }

            calculateScore(showModal = true) {
                const territories = this.calculateTerritories();
                let playerScore = 0;
                let computerScore = 0;

                territories.forEach(territory => {
                    if (territory.owner === 'player') {
                        playerScore += territory.points.length;
                    } else if (territory.owner === 'computer') {
                        computerScore += territory.points.length;
                    }
                });

                this.updateTerritoryDisplay(territories);

                // ì„ ê³µì´ 3ì  ì´ìƒ ì•ì„œì•¼ ìŠ¹ë¦¬ (ì»´í“¨í„°ê°€ ì„ ê³µ)
                let winner;
                if (computerScore - playerScore >= 3) {
                    winner = 'computer';
                } else {
                    winner = 'player';
                }

                this.logMessage(`ì ìˆ˜ ê³„ì‚°: ë‹¹ì‹  ${playerScore}ì , ì»´í“¨í„° ${computerScore}ì `);

                if (showModal) {
                    this.endGame(winner, 'ì ìˆ˜');
                }

                return { playerScore, computerScore, winner };
            }

            updateTerritoryDisplay(territories) {
                // ëª¨ë“  ì˜í†  í‘œì‹œ ì´ˆê¸°í™”
                document.querySelectorAll('.intersection').forEach(el => {
                    el.classList.remove('territory', 'player-territory', 'computer-territory');
                });

                // ì˜í†  í‘œì‹œ
                territories.forEach(territory => {
                    territory.points.forEach(index => {
                        const element = document.querySelector(`[data-index="${index}"]`);
                        element.classList.add('territory');
                        if (territory.owner === 'player') {
                            element.classList.add('player-territory');
                        } else if (territory.owner === 'computer') {
                            element.classList.add('computer-territory');
                        }
                    });
                });
            }

            endGame(winner, reason) {
                this.gameEnded = true;
                const { playerScore, computerScore } = this.calculateScore(false);
                
                let title, message;
                if (reason === 'í¬íš ìŠ¹ë¦¬') {
                    title = winner === 'player' ? 'ìŠ¹ë¦¬!' : 'íŒ¨ë°°!';
                    message = `${winner === 'player' ? 'ë‹¹ì‹ ì´' : 'ì»´í“¨í„°ê°€'} ìƒëŒ€ë°© ëŒì„ í¬íší•˜ì—¬ ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤!`;
                } else {
                    title = winner === 'player' ? 'ìŠ¹ë¦¬!' : 'íŒ¨ë°°!';
                    message = `ìµœì¢… ì ìˆ˜: ë‹¹ì‹  ${playerScore}ì , ì»´í“¨í„° ${computerScore}ì \n${winner === 'player' ? 'ë‹¹ì‹ ì´' : 'ì»´í“¨í„°ê°€'} ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤!`;
                }

                document.getElementById('gameOverTitle').textContent = title;
                document.getElementById('gameOverMessage').textContent = message;
                document.getElementById('gameOverModal').style.display = 'flex';
            }

            updateDisplay() {
                // ë³´ë“œ ì—…ë°ì´íŠ¸
                for (let i = 0; i < 81; i++) {
                    const element = document.querySelector(`[data-index="${i}"]`);
                    element.innerHTML = '';
                    
                    if (this.board[i] !== null) {
                        const stone = document.createElement('div');
                        stone.className = `stone ${this.board[i]}`;
                        element.appendChild(stone);
                    }
                }

                // ìƒíƒœ ì •ë³´ ì—…ë°ì´íŠ¸
                document.getElementById('playerStones').textContent = this.playerStones;
                document.getElementById('computerStones').textContent = this.computerStones;

                const { playerScore, computerScore } = this.calculateScore(false);
                document.getElementById('playerTerritory').textContent = playerScore;
                document.getElementById('computerTerritory').textContent = computerScore;

                // ê²Œì„ ìƒíƒœ í‘œì‹œ
                if (!this.gameEnded) {
                    const statusText = this.currentPlayer === 'player' ? 
                        'ë‹¹ì‹ ì˜ ì°¨ë¡€ì…ë‹ˆë‹¤ (íŒŒë€ìƒ‰ ëŒ)' : 
                        'ì»´í“¨í„°ê°€ ìƒê° ì¤‘ì…ë‹ˆë‹¤ (ì£¼í™©ìƒ‰ ëŒ)';
                    document.getElementById('gameStatus').textContent = statusText;
                }

                // ë²„íŠ¼ ìƒíƒœ
                document.getElementById('passBtn').disabled = this.currentPlayer !== 'player' || this.gameEnded;
            }

            indexToCoord(index) {
                const row = Math.floor(index / 9);
                const col = index % 9;
                return `(${row + 1}, ${col + 1})`;
            }

            logMessage(message) {
                this.gameLog.unshift(message);
                if (this.gameLog.length > 10) {
                    this.gameLog.pop();
                }

                const logContent = document.getElementById('gameLogContent');
                logContent.innerHTML = this.gameLog.map(msg => 
                    `<div class="log-entry">${msg}</div>`
                ).join('');
            }

            resetGame() {
                document.getElementById('gameOverModal').style.display = 'none';
                this.board = Array(81).fill(null);
                this.currentPlayer = 'computer'; // ì»´í“¨í„°ê°€ ì„ ê³µ
                this.playerStones = 40;
                this.computerStones = 40;
                this.consecutivePasses = 0;
                this.gameEnded = false;
                this.gameLog = [];
                
                this.placeNeutralStone();
                this.updateDisplay();
                this.logMessage("ìƒˆ ê²Œì„ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤!");
                this.logMessage("ì¤‘ì•™ì— ì¤‘ë¦½ ëŒì´ ë°°ì¹˜ë˜ì—ˆìŠµë‹ˆë‹¤.");
                this.logMessage("ì»´í“¨í„°ê°€ ì„ ê³µ(ì£¼í™©ìƒ‰)ì…ë‹ˆë‹¤.");
                
                // ì˜í†  í‘œì‹œ ì´ˆê¸°í™”
                document.querySelectorAll('.intersection').forEach(el => {
                    el.classList.remove('territory', 'player-territory', 'computer-territory');
                });
                
                setTimeout(() => this.computerMove(), 1000);
            }
        }

        // ê²Œì„ ì´ˆê¸°í™”
        let game = new GreatKingdomGame();

        // ì „ì—­ í•¨ìˆ˜
        function resetGame() {
            game.resetGame();
        }
    </script>
</body>
</html>
