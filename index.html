<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>ê·¸ë ˆì´íŠ¸ í‚¹ë¤ - ì´ì„¸ëŒì˜ ìœ„ì¦ˆìŠ¤í†¤</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            min-height: 100vh;
            padding: 10px;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .game-container {
            max-width: 600px;
            margin: 0 auto;
            padding: 0 5px;
        }

        .game-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .game-header h1 {
            font-size: 2em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 5px;
        }

        .game-header .subtitle {
            font-size: 1.1em;
            color: #ecf0f1;
            opacity: 0.8;
        }

        /* ë‚œì´ë„ ì„ íƒ í™”ë©´ */
        .difficulty-screen {
            background: rgba(255,255,255,0.15);
            padding: 30px 20px;
            border-radius: 15px;
            text-align: center;
            border: 2px solid rgba(255,255,255,0.2);
            margin-bottom: 20px;
        }

        .difficulty-screen h2 {
            color: #f39c12;
            margin-bottom: 20px;
            font-size: 1.4em;
        }

        .difficulty-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin-bottom: 20px;
            max-width: 350px;
            margin-left: auto;
            margin-right: auto;
        }

        .difficulty-btn {
            background: rgba(255,255,255,0.2);
            color: white;
            border: 2px solid rgba(255,255,255,0.3);
            padding: 15px 10px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.3s ease;
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .difficulty-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.05);
        }

        .difficulty-btn.selected {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            border-color: #fff;
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
        }

        .difficulty-info {
            font-size: 16px;
            color: #ecf0f1;
            margin-bottom: 25px;
            min-height: 25px;
            font-weight: 500;
        }

        .start-btn {
            background: linear-gradient(135deg, #27ae60, #229954);
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .start-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(39, 174, 96, 0.4);
        }

        /* ê²Œì„ í™”ë©´ */
        .game-screen {
            display: none;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            gap: 10px;
        }

        .player-info, .computer-info {
            background: rgba(255,255,255,0.1);
            padding: 10px;
            border-radius: 8px;
            flex: 1;
            text-align: center;
            font-size: 0.9em;
        }

        .player-info {
            border-left: 4px solid #3498db;
        }

        .computer-info {
            border-left: 4px solid #e74c3c;
        }

        .score-display {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
        }

        .score-value {
            font-size: 1.2em;
            font-weight: bold;
        }

        .game-status {
            text-align: center;
            font-size: 1em;
            margin: 10px 0;
            padding: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
        }

        .game-board {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-gap: 1px;
            background: #2c3e50;
            padding: 5px;
            border-radius: 8px;
            margin: 15px auto;
            max-width: 90vw;
            width: 100%;
            aspect-ratio: 1;
        }

        .intersection {
            background: #34495e;
            border: 1px solid #2c3e50;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            min-height: 30px;
            touch-action: manipulation;
        }

        .intersection:hover {
            background: #3d566e;
        }

        .intersection:active {
            background: #4a6fa5;
            transform: scale(0.95);
        }

        .stone {
            width: 85%;
            height: 85%;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.7em;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            pointer-events: none;
        }

        .stone.player {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .stone.computer {
            background: linear-gradient(135deg, #e67e22, #d35400);
            color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .stone.neutral {
            background: linear-gradient(135deg, #95a5a6, #7f8c8d);
            color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .btn {
            background: linear-gradient(135deg, #8e44ad, #9b59b6);
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            touch-action: manipulation;
            -webkit-appearance: none;
            min-height: 44px;
            min-width: 60px;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(0,0,0,0.3);
        }

        .btn:active {
            transform: translateY(0);
            box-shadow: 0 1px 5px rgba(0,0,0,0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* ëª¨ë‹¬ */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-content {
            background: linear-gradient(135deg, #8e44ad, #9b59b6);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 350px;
            margin: 20px;
        }

        /* ëª¨ë°”ì¼ ìµœì í™” */
        @media (max-width: 480px) {
            .game-header h1 {
                font-size: 1.7em;
            }
            
            .difficulty-grid {
                max-width: 280px;
                gap: 8px;
            }
            
            .difficulty-btn {
                padding: 12px 8px;
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <h1>ğŸ° ê·¸ë ˆì´íŠ¸ í‚¹ë¤</h1>
            <div class="subtitle">ì´ì„¸ëŒì˜ ìœ„ì¦ˆìŠ¤í†¤</div>
        </div>

        <!-- ë‚œì´ë„ ì„ íƒ í™”ë©´ -->
        <div class="difficulty-screen" id="difficultyScreen">
            <h2>ğŸ¯ ë‚œì´ë„ ì„ íƒ</h2>
            <div class="difficulty-grid">
                <button class="difficulty-btn" data-level="1">1</button>
                <button class="difficulty-btn" data-level="2">2</button>
                <button class="difficulty-btn" data-level="3">3</button>
                <button class="difficulty-btn" data-level="4">4</button>
                <button class="difficulty-btn selected" data-level="5">5</button>
                <button class="difficulty-btn" data-level="6">6</button>
                <button class="difficulty-btn" data-level="7">7</button>
                <button class="difficulty-btn" data-level="8">8</button>
                <button class="difficulty-btn" data-level="9">9</button>
                <button class="difficulty-btn" data-level="10">10</button>
            </div>
            <div class="difficulty-info" id="difficultyInfo">
                ì¤‘ê°„ ë‚œì´ë„ - ì ë‹¹í•œ ë„ì „
            </div>
            <button class="start-btn" id="startGame">ê²Œì„ ì‹œì‘</button>
        </div>

        <!-- ê²Œì„ í™”ë©´ -->
        <div class="game-screen" id="gameScreen">
            <div class="game-info">
                <div class="player-info">
                    <h3>ğŸ”µ ë‹¹ì‹  (íŒŒë€ìƒ‰)</h3>
                    <div class="score-display">
                        <div>ì˜í† : <span class="score-value" id="playerTerritory">0</span></div>
                        <div>ëŒ: <span class="score-value" id="playerStones">40</span></div>
                    </div>
                </div>
                <div class="computer-info">
                    <h3>ğŸŸ  ì»´í“¨í„° (ì£¼í™©ìƒ‰)</h3>
                    <div class="score-display">
                        <div>ì˜í† : <span class="score-value" id="computerTerritory">0</span></div>
                        <div>ëŒ: <span class="score-value" id="computerStones">40</span></div>
                    </div>
                </div>
            </div>

            <div class="game-status" id="gameStatus">ê²Œì„ ì¤€ë¹„ ì¤‘...</div>

            <div class="game-board" id="gameBoard"></div>

            <div class="controls">
                <button class="btn" id="passBtn">íŒ¨ìŠ¤</button>
                <button class="btn" id="calculateBtn">ì ìˆ˜ ê³„ì‚°</button>
                <button class="btn" id="newGameBtn">ìƒˆ ê²Œì„</button>
            </div>
        </div>
    </div>

    <!-- ê²Œì„ ì¢…ë£Œ ëª¨ë‹¬ -->
    <div class="modal" id="gameOverModal">
        <div class="modal-content">
            <h2 id="gameOverTitle"></h2>
            <p id="gameOverMessage"></p>
            <button class="btn" id="playAgainBtn">ë‹¤ì‹œ í•˜ê¸°</button>
        </div>
    </div>

    <script>
        let selectedDifficulty = 5;
        let gameInstance = null;

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ì´ë²¤íŠ¸ ì„¤ì •
        document.addEventListener('DOMContentLoaded', function() {
            initializeDifficultySelector();
        });

        function initializeDifficultySelector() {
            // ë‚œì´ë„ ë²„íŠ¼ë“¤
            const difficultyButtons = document.querySelectorAll('.difficulty-btn');
            difficultyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    // ì´ì „ ì„ íƒ í•´ì œ
                    document.querySelectorAll('.difficulty-btn').forEach(b => {
                        b.classList.remove('selected');
                    });
                    
                    // ìƒˆë¡œìš´ ì„ íƒ
                    this.classList.add('selected');
                    selectedDifficulty = parseInt(this.dataset.level);
                    updateDifficultyDescription();
                });
            });

            // ê²Œì„ ì‹œì‘ ë²„íŠ¼
            document.getElementById('startGame').addEventListener('click', function() {
                startNewGame();
            });

            // ê²Œì„ ë²„íŠ¼ë“¤
            document.getElementById('passBtn').addEventListener('click', function() {
                if (gameInstance && gameInstance.currentPlayer === 'player' && !gameInstance.gameEnded) {
                    gameInstance.pass();
                }
            });

            document.getElementById('calculateBtn').addEventListener('click', function() {
                if (gameInstance) {
                    gameInstance.calculateScore(true);
                }
            });

            document.getElementById('newGameBtn').addEventListener('click', function() {
                backToMenu();
            });

            document.getElementById('playAgainBtn').addEventListener('click', function() {
                backToMenu();
            });

            // ë³´ë“œ í´ë¦­
            document.getElementById('gameBoard').addEventListener('click', function(e) {
                if (e.target.classList.contains('intersection') && gameInstance && 
                    gameInstance.currentPlayer === 'player' && !gameInstance.gameEnded) {
                    const index = parseInt(e.target.dataset.index);
                    gameInstance.makeMove(index, 'player');
                }
            });

            updateDifficultyDescription();
        }

        function updateDifficultyDescription() {
            const descriptions = {
                1: "ì´ˆë³´ì - AIê°€ ê±°ì˜ ëœë¤í•˜ê²Œ ì›€ì§ì…ë‹ˆë‹¤",
                2: "ì‰¬ì›€ - ê¸°ë³¸ì ì¸ íŒ¨í„´ë§Œ ì‚¬ìš©í•©ë‹ˆë‹¤", 
                3: "ì•½ê°„ ì‰¬ì›€ - ê°„ë‹¨í•œ ì „ëµì„ ì‚¬ìš©í•©ë‹ˆë‹¤",
                4: "ì‰¬ìš´ í¸ - ê³µê²©ê³¼ ë°©ì–´ë¥¼ ì¡°ê¸ˆ ìƒê°í•©ë‹ˆë‹¤",
                5: "ì¤‘ê°„ ë‚œì´ë„ - ì ë‹¹í•œ ë„ì „",
                6: "ì•½ê°„ ì–´ë ¤ì›€ - ì˜í†  í™•ì¥ì„ ìš°ì„ ì‹œí•©ë‹ˆë‹¤",
                7: "ì–´ë ¤ì›€ - ì „ëµì  ì‚¬ê³ ë¥¼ í•©ë‹ˆë‹¤",
                8: "ìƒë‹¹íˆ ì–´ë ¤ì›€ - ê³ ê¸‰ ì „ìˆ ì„ ì‚¬ìš©í•©ë‹ˆë‹¤",
                9: "ë§¤ìš° ì–´ë ¤ì›€ - ì—¬ëŸ¬ ìˆ˜ë¥¼ ë¯¸ë¦¬ ê³„ì‚°í•©ë‹ˆë‹¤",
                10: "ê·¹í•œ ë‚œì´ë„ - í”„ë¡œ ìˆ˜ì¤€ì˜ AI"
            };
            
            document.getElementById('difficultyInfo').textContent = descriptions[selectedDifficulty];
        }

        function startNewGame() {
            document.getElementById('difficultyScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';
            
            gameInstance = new GreatKingdomGame(selectedDifficulty);
        }

        function backToMenu() {
            document.getElementById('gameOverModal').style.display = 'none';
            document.getElementById('difficultyScreen').style.display = 'block';
            document.getElementById('gameScreen').style.display = 'none';
            gameInstance = null;
        }

        class GreatKingdomGame {
            constructor(difficulty) {
                this.difficulty = difficulty;
                this.board = Array(81).fill(null);
                this.currentPlayer = 'computer';
                this.playerStones = 40;
                this.computerStones = 40;
                this.consecutivePasses = 0;
                this.gameEnded = false;
                
                this.initializeGame();
            }

            initializeGame() {
                this.createBoard();
                this.placeNeutralStone();
                this.updateDisplay();
                
                document.getElementById('gameStatus').textContent = `ë‚œì´ë„ ${this.difficulty} - ì»´í“¨í„°ê°€ ë¨¼ì € ì‹œì‘í•©ë‹ˆë‹¤...`;
                setTimeout(() => this.computerMove(), 1500);
            }

            createBoard() {
                const boardElement = document.getElementById('gameBoard');
                boardElement.innerHTML = '';

                for (let i = 0; i < 81; i++) {
                    const intersection = document.createElement('div');
                    intersection.className = 'intersection';
                    intersection.dataset.index = i;
                    boardElement.appendChild(intersection);
                }
            }

            placeNeutralStone() {
                this.board[40] = 'neutral';
            }

            makeMove(index, player) {
                if (this.board[index] !== null) {
                    return false;
                }

                this.board[index] = player;
                this.consecutivePasses = 0;

                if (player === 'player') {
                    this.playerStones--;
                } else {
                    this.computerStones--;
                }

                this.checkCaptures(player);
                this.updateDisplay();
                
                if (!this.gameEnded) {
                    this.switchPlayer();
                }
                
                return true;
            }

            checkCaptures(player) {
                const opponent = player === 'player' ? 'computer' : 'player';
                let capturedCount = 0;

                for (let i = 0; i < 81; i++) {
                    if (this.board[i] === opponent) {
                        const group = this.getGroup(i);
                        if (this.isCaptured(group)) {
                            group.forEach(index => {
                                this.board[index] = null;
                                capturedCount++;
                            });
                        }
                    }
                }

                if (capturedCount > 0) {
                    this.endGame(player, 'í¬íš ìŠ¹ë¦¬');
                }
            }

            getGroup(startIndex) {
                if (this.board[startIndex] === null) return [];
                
                const color = this.board[startIndex];
                const group = [];
                const visited = new Set();
                const stack = [startIndex];

                while (stack.length > 0) {
                    const index = stack.pop();
                    if (visited.has(index)) continue;
                    
                    visited.add(index);
                    if (this.board[index] === color) {
                        group.push(index);
                        
                        const neighbors = this.getNeighbors(index);
                        neighbors.forEach(neighbor => {
                            if (!visited.has(neighbor) && this.board[neighbor] === color) {
                                stack.push(neighbor);
                            }
                        });
                    }
                }

                return group;
            }

            isCaptured(group) {
                for (let index of group) {
                    const neighbors = this.getNeighbors(index);
                    for (let neighbor of neighbors) {
                        if (this.board[neighbor] === null) {
                            return false;
                        }
                    }
                }
                return true;
            }

            getNeighbors(index) {
                const neighbors = [];
                const row = Math.floor(index / 9);
                const col = index % 9;

                const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                
                directions.forEach(([dr, dc]) => {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    
                    if (newRow >= 0 && newRow < 9 && newCol >= 0 && newCol < 9) {
                        neighbors.push(newRow * 9 + newCol);
                    }
                });

                return neighbors;
            }

			// ==== ë‚œì´ë„ë³„ ìˆ˜ì½ê¸°/ëœë¤ íŒŒë¼ë¯¸í„° ====
			difficultyParams(d) {
				// depth: íƒìƒ‰ ê¹Šì´, topK: ê° í„´ì—ì„œ ìƒìœ„ í›„ë³´ë§Œ íƒìƒ‰(ì†ë„â†‘), noise: ë™ì /ìœ ì‚¬ì ìˆ˜ ì‹œ ì•½ê°„ì˜ ë¬´ì‘ìœ„
				if (d <= 3) return { depth: 0, topK: 0, noise: 0.30, playstyle: "random" };
				if (d <= 6) return { depth: 0, topK: 0, noise: 0.10, playstyle: "heuristic" };
				if (d <= 8) return { depth: 1, topK: 10, noise: 0.05, playstyle: "lookahead" };
				if (d === 9) return { depth: 2, topK: 8, noise: 0.02, playstyle: "minimax" };
				return { depth: 2, topK: 12, noise: 0.00, playstyle: "minimax" }; // 10
			}

            

			// ==== ì»´í“¨í„° ìˆ˜ ====
			computerMove() {
				if (this.gameEnded) return;

				// ìì‚´ìˆ˜ë¥¼ ì œì™¸í•œ ìœ íš¨ ìˆ˜ë§Œ í›„ë³´ë¡œ
				const candidates = this.getValidMoves('computer', true);
				if (candidates.length === 0) {
					this.pass();
					return;
				}

				const params = this.difficultyParams(this.difficulty);

				// 1) ì¦‰ì‹œ í¬íš ìŠ¹ë¦¬ ìˆ˜(ìƒëŒ€ ëŒ í•˜ë‚˜ë¼ë„ ì œê±°ë˜ëŠ” ìˆ˜) ìˆìœ¼ë©´ ìµœìš°ì„ 
				const captureMoves = [];
				for (let mv of candidates) {
					const sim = this.simulateMove(this.board, mv, 'computer');
					if (sim.valid && sim.captured > 0) captureMoves.push({ move: mv, cap: sim.captured });
				}
				if (captureMoves.length > 0) {
					// ìµœëŒ€ í¬íš ìˆ˜ ìœ„ì£¼ë¡œ, ë™ì ì´ë©´ ëœë¤
					const maxCap = Math.max(...captureMoves.map(m => m.cap));
					const bestCaps = captureMoves.filter(m => m.cap === maxCap);
					const chosen = bestCaps[Math.floor(Math.random() * bestCaps.length)].move;
					this.makeMove(chosen, 'computer');
					return;
				}

				let chosenMove;

				// 2) ë‚œì´ë„ë³„ ì˜ì‚¬ê²°ì •
				if (params.depth === 0 && params.playstyle === "random") {
					// ì‰¬ì›€: ëœë¤ + ì•½ê°„ ì¤‘ì•™ ì„ í˜¸
					if (Math.random() < 0.7) {
						chosenMove = candidates[Math.floor(Math.random() * candidates.length)];
					} else {
						const centers = this.getCenterMoves(candidates);
						chosenMove = centers.length ? centers[Math.floor(Math.random() * centers.length)]
													: candidates[Math.floor(Math.random() * candidates.length)];
					}
				} else if (params.depth === 0 && params.playstyle === "heuristic") {
					// ì¤‘ê°„: ì—°ê²°ì„±/ì¤‘ì•™/ê³µê²© ê¸°íšŒë¥¼ í‰ê°€í•´ì„œ ìƒìœ„ ì¤‘ í•˜ë‚˜ ì„ íƒ
					const scored = candidates.map(mv => {
						const sim = this.simulateMove(this.board, mv, 'computer');
						return { move: mv, score: this.evaluateBoard(sim.board) + this.evaluateMoveHeuristic(mv, 'computer') };
					}).sort((a,b) => b.score - a.score);

					// ìƒìœ„ 5ê°œ ì¤‘ í•˜ë‚˜ (ì•½ê°„ ëœë¤)
					const bucket = scored.slice(0, Math.min(5, scored.length));
					chosenMove = bucket[Math.floor(Math.random() * bucket.length)].move;

				} else if (params.depth === 1) {
					// ìƒìœ„ í›„ë³´ 10ê°œë¡œ 1ìˆ˜ ì•ë³´ê¸°(ìƒëŒ€ ìµœì„  ì‘ìˆ˜ ê³ ë ¤)
					const ordered = this.orderMovesByHeuristic(this.board, 'computer', candidates);
					const top = ordered.slice(0, Math.min(params.topK, ordered.length));
					let best = { move: top[0], score: -Infinity };

					for (let mv of top) {
						const sim = this.simulateMove(this.board, mv, 'computer');
						if (!sim.valid) continue;
						// ìƒëŒ€ê°€ ê°€ì¥ ì¢‹ê²Œ ì‘ìˆ˜í–ˆì„ ë•Œ ì ìˆ˜ (ìµœì•… ê°€ì •)
						const oppMoves = this.getValidMoves('player', true, sim.board);
						let oppBest = Infinity;
						if (oppMoves.length === 0) {
							oppBest = -this.evaluateBoard(sim.board); // ìƒëŒ€ê°€ ëª» ë‘ë©´ ìš°ë¦¬ ìœ ë¦¬
						} else {
							const oppOrdered = this.orderMovesByHeuristic(sim.board, 'player', oppMoves).slice(0, 8);
							for (let omv of oppOrdered) {
								const sim2 = this.simulateMove(sim.board, omv, 'player');
								if (!sim2.valid) continue;
								// ì¦‰ì‹œ í¬íš ë‹¹í•˜ëŠ” ë¼ì¸ ë°©ì§€
								let val = this.evaluateBoard(sim2.board);
								if (sim2.captured > 0) val -= 50;
								oppBest = Math.min(oppBest, val);
							}
						}
						const myScore = -oppBest; // ìƒëŒ€ ìµœì„  ì‘ìˆ˜ ëŒ€ë¹„
						// ì†ŒëŸ‰ ë…¸ì´ì¦ˆë¡œ ë™ì  ë°˜ë³µ ë°©ì§€
						const noise = (Math.random() - 0.5) * 2 * params.noise;
						if (myScore + noise > best.score) best = { move: mv, score: myScore + noise };
					}
					chosenMove = best.move;

				} else {
					// ìƒìœ„ í›„ë³´ë§Œ ë‘ê³  ì•ŒíŒŒ-ë² íƒ€ ë¯¸ë‹ˆë§¥ìŠ¤ (ê¹Šì´ 2)
					const ordered = this.orderMovesByHeuristic(this.board, 'computer', candidates);
					const top = ordered.slice(0, Math.min(params.topK, ordered.length));
					let best = { move: top[0], score: -Infinity };

					let alpha = -Infinity, beta = Infinity;
					for (let mv of top) {
						const sim = this.simulateMove(this.board, mv, 'computer');
						if (!sim.valid) continue;

						// ì¦‰ì‹œ í¬íšì€ ì•ì—ì„œ ê±¸ë €ìœ¼ë¯€ë¡œ ì—¬ê¸°ì„  í‰ê°€ë§Œ
						const val = this.alphabeta(sim.board, params.depth - 1, false, alpha, beta);
						if (val > best.score) {
							best = { move: mv, score: val };
						}
						alpha = Math.max(alpha, val);
						if (beta <= alpha) break;
					}
					chosenMove = best.move;
				}

				this.makeMove(chosenMove, 'computer');
			}


			// ==== ì•ŒíŒŒ-ë² íƒ€ íƒìƒ‰ ====
			alphabeta(boardState, depth, maximizing, alpha, beta) {
				if (depth === 0) return this.evaluateBoard(boardState);

				const me = maximizing ? 'computer' : 'player';
				const moves = this.getValidMoves(me, true, boardState);
				if (moves.length === 0) return this.evaluateBoard(boardState);

				const ordered = this.orderMovesByHeuristic(boardState, me, moves)
					.slice(0, maximizing ? 10 : 10); // ìˆ˜ê°€ ë§ì„ ë•Œ ê°€ì§€ì¹˜ê¸°

				if (maximizing) {
					let value = -Infinity;
					for (let mv of ordered) {
						const sim = this.simulateMove(boardState, mv, me);
						if (!sim.valid) continue;
						if (sim.captured > 0) return 9999; // ì¦‰ì‹œ í¬íš ìŠ¹ = ê±°ì˜ í™•ì •ìŠ¹
						value = Math.max(value, this.alphabeta(sim.board, depth - 1, false, alpha, beta));
						alpha = Math.max(alpha, value);
						if (beta <= alpha) break;
					}
					return value;
				} else {
					let value = Infinity;
					for (let mv of ordered) {
						const sim = this.simulateMove(boardState, mv, me);
						if (!sim.valid) continue;
						if (sim.captured > 0) return -9999; // ìƒëŒ€ê°€ ì¦‰ì‹œ í¬íš = í° ìœ„ê¸°
						value = Math.min(value, this.alphabeta(sim.board, depth - 1, true, alpha, beta));
						beta = Math.min(beta, value);
						if (beta <= alpha) break;
					}
					return value;
				}
			}


			// ==== í›„ë³´ ì •ë ¬(ê°€ë²¼ìš´ íœ´ë¦¬ìŠ¤í‹±) ====
			orderMovesByHeuristic(boardState, player, moves) {
				const scored = [];
				for (let mv of moves) {
					const sim = this.simulateMove(boardState, mv, player);
					if (!sim.valid) continue;
					let s = this.evaluateBoard(sim.board);

					// ê°€ì¤‘ ë³´ë„ˆìŠ¤: ì¤‘ì‹¬, ì—°ê²°, ìƒëŒ€ ì¸ì ‘(ê³µê²© ê¸°íšŒ), í¬íš ì§ì „(atari) ë§Œë“¤ê¸°
					s += this.evaluateMoveHeuristic(mv, player, boardState) + sim.captured * 50;
					scored.push({ mv, s });
				}
				scored.sort((a,b) => b.s - a.s);
				return scored.map(o => o.mv);
			}


			// ==== ê°„ë‹¨ íœ´ë¦¬ìŠ¤í‹±(ë¹ ë¥¸ ì •ë ¬ìš©) ====
			evaluateMoveHeuristic(move, player, boardState = this.board) {
				const row = Math.floor(move / 9);
				const col = move % 9;
				let score = 0;

				// ì¤‘ì‹¬ ì„ í˜¸ (ê°€ê¹Œìš¸ìˆ˜ë¡ +)
				const centerDistance = Math.abs(row - 4) + Math.abs(col - 4);
				score += (8 - centerDistance) * 0.6;

				// ì—°ê²°ì„± (ì¸ì ‘ ì•„êµ° ìˆ˜)
				const neighbors = this.getNeighbors(move);
				const friendlyNeighbors = neighbors.filter(n => boardState[n] === player).length;
				score += friendlyNeighbors * 2.5;

				// ê³µê²© ê¸°íšŒ (ì¸ì ‘ ì êµ° ìˆ˜)
				const opponent = (player === 'player') ? 'computer' : 'player';
				const enemyNeighbors = neighbors.filter(n => boardState[n] === opponent).length;
				score += enemyNeighbors * 1.8;

				// ìì‚´ ìœ„í—˜(ì‹œë®¬) í˜ë„í‹°
				const sim = this.simulateMove(boardState, move, player);
				if (!sim.valid) score -= 100;

				// Atari ìœ ë„(ìƒëŒ€ ê·¸ë£¹ í•œìˆ¨) ë³´ë„ˆìŠ¤
				const atariDelta = this.countAtari(sim.board, opponent) - this.countAtari(boardState, opponent);
				score += atariDelta * 3;

				return score;
			}



			// --- ë‹¨ìˆœ ì ìˆ˜ ê¸°ë°˜ ì„ íƒ ---
			pickBest(moves, player) {
				let bestScore = -Infinity;
				let bestMove = moves[0];
				for (let move of moves) {
					const score = this.evaluateMove(move, player);
					if (score > bestScore) {
						bestScore = score;
						bestMove = move;
					}
				}
				return bestMove;
			}

			// --- ë¯¸ë‹ˆë§¥ìŠ¤ ê¸°ë°˜ ì„ íƒ ---
			minimaxPick(validMoves, depth) {
				let bestScore = -Infinity;
				let bestMove = validMoves[0];

				for (let move of validMoves) {
					// ê°€ìƒìœ¼ë¡œ ìˆ˜ ë‘ê¸°
					this.board[move] = 'computer';
					const score = this.minimax(depth - 1, false);
					this.board[move] = null;

					if (score > bestScore) {
						bestScore = score;
						bestMove = move;
					}
				}
				return bestMove;
			}

			minimax(depth, isMax) {
				if (depth === 0) {
					return this.evaluateBoard();
				}

				const validMoves = this.getValidMoves(isMax ? 'computer' : 'player');
				if (validMoves.length === 0) return this.evaluateBoard();

				let bestScore = isMax ? -Infinity : Infinity;

				for (let move of validMoves) {
					this.board[move] = isMax ? 'computer' : 'player';
					const score = this.minimax(depth - 1, !isMax);
					this.board[move] = null;

					if (isMax) {
						bestScore = Math.max(bestScore, score);
					} else {
						bestScore = Math.min(bestScore, score);
					}
				}
				return bestScore;
			}

			// ==== ë³´ë“œ í‰ê°€(ì „ë°˜ì  ìš°ì„¸ë„) ====
			evaluateBoard(boardState = this.board) {
				// 1) ëŒ ê°œìˆ˜ ì°¨
				let my = 0, opp = 0;
				for (let i = 0; i < 81; i++) {
					if (boardState[i] === 'computer') my++;
					else if (boardState[i] === 'player') opp++;
				}
				let score = (my - opp) * 2.0;

				// 2) ê·¸ë£¹ ììœ  í•©(ë¦¬ë²„í‹°) ì°¨
				const gInfo = this.collectGroups(boardState);
				score += (gInfo.libComputer - gInfo.libPlayer) * 0.5;

				// 3) ì¤‘ì‹¬/ì—°ê²°ì„± ì˜í–¥
				score += (gInfo.centerComputer - gInfo.centerPlayer) * 0.3;
				score += (gInfo.connComputer - gInfo.connPlayer) * 0.5;

				// 4) Atari(í•œìˆ¨ ë‚¨ì€ ê·¸ë£¹) ë°¸ëŸ°ìŠ¤: ìƒëŒ€ê°€ í•œìˆ¨ì¸ ê·¸ë£¹ ë§ìœ¼ë©´ +
				score += (gInfo.atariPlayer - gInfo.atariComputer) * 3.0; // playerê°€ ê³¤ë€í• ìˆ˜ë¡ ìš°ë¦¬ ìœ ë¦¬

				return score;
			}

			collectGroups(boardState) {
				const visited = new Set();
				const dirs = [[-1,0],[1,0],[0,-1],[0,1]];
				let libP=0, libC=0, ctrP=0, ctrC=0, connP=0, connC=0, atariP=0, atariC=0;

				for (let i=0;i<81;i++){
					const color = boardState[i];
					if (color === null || visited.has(i)) continue;

					const grp = this.getGroupFromBoard(boardState, i, color, visited);
					const libs = this.getLibertiesFromBoard(boardState, grp);
					const isAtari = (libs === 1);

					// ì¤‘ì‹¬/ì—°ê²°ì„± ê³„ì‚°
					let centerSum = 0, connSum = 0;
					for (let idx of grp) {
						const r = Math.floor(idx/9), c = idx%9;
						centerSum += (8 - (Math.abs(r-4)+Math.abs(c-4)));
						for (let [dr,dc] of dirs) {
							const nr=r+dr,nc=c+dc;
							if (nr<0||nr>=9||nc<0||nc>=9) continue;
							const ni = nr*9+nc;
							if (boardState[ni] === color) connSum++;
						}
					}

					if (color === 'player') {
						libP += libs;
						ctrP += centerSum / grp.length;
						connP += connSum;
						if (isAtari) atariP++;
					} else {
						libC += libs;
						ctrC += centerSum / grp.length;
						connC += connSum;
						if (isAtari) atariC++;
					}
				}
				return {
					libPlayer: libP, libComputer: libC,
					centerPlayer: ctrP, centerComputer: ctrC,
					connPlayer: connP, connComputer: connC,
					atariPlayer: atariP, atariComputer: atariC
				};
			}


			countAtari(boardState, color) {
				const visited = new Set();
				let cnt = 0;
				for (let i=0;i<81;i++){
					if (boardState[i] !== color || visited.has(i)) continue;
					const grp = this.getGroupFromBoard(boardState, i, color, visited);
					const libs = this.getLibertiesFromBoard(boardState, grp);
					if (libs === 1) cnt++;
				}
				return cnt;
			}


			getGroupFromBoard(boardState, start, color, visited) {
				const stack = [start];
				const grp = [];
				while (stack.length) {
					const idx = stack.pop();
					if (visited.has(idx)) continue;
					visited.add(idx);
					if (boardState[idx] !== color) continue;
					grp.push(idx);
					const neigh = this.getNeighbors(idx);
					for (let n of neigh) {
						if (!visited.has(n) && boardState[n] === color) stack.push(n);
					}
				}
				return grp;
			}

			getLibertiesFromBoard(boardState, group) {
				const seen = new Set();
				let libs = 0;
				for (let idx of group) {
					const neigh = this.getNeighbors(idx);
					for (let n of neigh) {
						if (boardState[n] === null && !seen.has(n)) {
							seen.add(n); libs++;
						}
					}
				}
				return libs;
			}



			// ==== ë‹¨ì¼ ìˆ˜ ì‹œë®¬ë ˆì´ì…˜(í¬íš/ìì‚´ íŒì • í¬í•¨) ====
			simulateMove(boardState, move, player) {
				if (boardState[move] !== null) return { valid: false, board: boardState, captured: 0 };
				const b = boardState.slice();
				const opponent = (player === 'player') ? 'computer' : 'player';

				// 1) ì°©ìˆ˜
				b[move] = player;

				// 2) ìƒëŒ€ ê·¸ë£¹ë“¤ ì¤‘ ììœ (ë¹ˆì¹¸)ê°€ 0ì¸ ê²ƒ ì œê±° = í¬íš
				let captured = 0;
				const visited = new Set();
				for (let i = 0; i < 81; i++) {
					if (b[i] !== opponent || visited.has(i)) continue;
					const grp = this.getGroupFromBoard(b, i, opponent, visited);
					const libs = this.getLibertiesFromBoard(b, grp);
					if (libs === 0) {
						for (let idx of grp) { b[idx] = null; captured++; }
					}
				}

				// 3) ë‚´ ëŒì´ ìì‚´ì¸ì§€ í™•ì¸ (ì°©ìˆ˜í•œ ê·¸ë£¹ì˜ ììœ ê°€ 0ì´ë©´ ë¬´íš¨)
				const myVisited = new Set();
				const myGroup = this.getGroupFromBoard(b, move, player, myVisited);
				const myLibs = this.getLibertiesFromBoard(b, myGroup);
				if (myLibs === 0) {
					return { valid: false, board: boardState, captured: 0 };
				}

				return { valid: true, board: b, captured };
			}


            // ==== ìœ íš¨ ìˆ˜ ëª©ë¡ (avoidSuicide=trueë©´ ìì‚´ìˆ˜ ì œì™¸). boardOverrideë¡œ ì„ì˜ ë³´ë“œ í‰ê°€ ê°€ëŠ¥ ====
			getValidMoves(player, avoidSuicide = false, boardOverride = null) {
				const b = boardOverride || this.board;
				const valid = [];
				for (let i = 0; i < 81; i++) {
					if (b[i] !== null) continue;
					if (!avoidSuicide) {
						valid.push(i);
					} else {
						const sim = this.simulateMove(b, i, player);
						if (sim.valid) valid.push(i);
					}
				}
				return valid;
			}





            getCenterMoves(moves) {
                return moves.filter(move => {
                    const row = Math.floor(move / 9);
                    const col = move % 9;
                    return row >= 3 && row <= 5 && col >= 3 && col <= 5;
                });
            }

            getConnectedMoves(moves, player) {
                return moves.filter(move => {
                    const neighbors = this.getNeighbors(move);
                    return neighbors.some(neighbor => this.board[neighbor] === player);
                });
            }

            evaluateMove(move, player) {
                let score = 0;
                const row = Math.floor(move / 9);
                const col = move % 9;
                
                // ì¤‘ì‹¬ë¶€ ì„ í˜¸
                const centerDistance = Math.abs(row - 4) + Math.abs(col - 4);
                score += (8 - centerDistance) * 0.5;
                
                // ìì‹ ì˜ ëŒê³¼ ì—°ê²°ì„±
                const neighbors = this.getNeighbors(move);
                const friendlyNeighbors = neighbors.filter(n => this.board[n] === player).length;
                score += friendlyNeighbors * 3;
                
                // ìƒëŒ€ë°© ëŒ ê·¼ì²˜ (ê³µê²© ê¸°íšŒ)
                const enemyNeighbors = neighbors.filter(n => this.board[n] === (player === 'player' ? 'computer' : 'player')).length;
                score += enemyNeighbors * 2;
                
                return score;
            }

            pass() {
                this.consecutivePasses++;
                
                if (this.consecutivePasses >= 2) {
                    this.calculateScore(false);
                    return;
                }

                this.switchPlayer();
            }

            switchPlayer() {
                if (this.gameEnded) return;
                
                this.currentPlayer = this.currentPlayer === 'player' ? 'computer' : 'player';
                this.updateDisplay();

                if (this.currentPlayer === 'computer') {
                    setTimeout(() => this.computerMove(), 800);
                }
            }

            calculateScore(showModal = true) {
                // ê°„ë‹¨í•œ ì ìˆ˜ ê³„ì‚°: ë³´ë“œ ìœ„ì˜ ëŒ ê°œìˆ˜
                let playerScore = 0;
                let computerScore = 0;

                for (let i = 0; i < 81; i++) {
                    if (this.board[i] === 'player') {
                        playerScore++;
                    } else if (this.board[i] === 'computer') {
                        computerScore++;
                    }
                }

                // ì„ ê³µ(ì»´í“¨í„°)ì´ 3ì  ì´ìƒ ì•ì„œì•¼ ìŠ¹ë¦¬
                let winner;
                if (computerScore - playerScore >= 3) {
                    winner = 'computer';
                } else {
                    winner = 'player';
                }

                if (showModal) {
                    this.endGame(winner, 'ì ìˆ˜');
                }

                return { playerScore, computerScore, winner };
            }

            endGame(winner, reason) {
                this.gameEnded = true;
                const { playerScore, computerScore } = this.calculateScore(false);
                
                let title = winner === 'player' ? 'ğŸ‰ ìŠ¹ë¦¬!' : 'ğŸ˜¢ íŒ¨ë°°!';
                let message = `ìµœì¢… ì ìˆ˜: ë‹¹ì‹  ${playerScore}ì , ì»´í“¨í„° ${computerScore}ì `;
                
                if (reason === 'í¬íš ìŠ¹ë¦¬') {
                    message = `${winner === 'player' ? 'ë‹¹ì‹ ì´' : 'ì»´í“¨í„°ê°€'} ìƒëŒ€ë°© ëŒì„ í¬íší•˜ì—¬ ìŠ¹ë¦¬!`;
                }

                document.getElementById('gameOverTitle').textContent = title;
                document.getElementById('gameOverMessage').textContent = message;
                document.getElementById('gameOverModal').style.display = 'flex';
            }

            updateDisplay() {
                // ë³´ë“œ ì—…ë°ì´íŠ¸
                for (let i = 0; i < 81; i++) {
                    const element = document.querySelector(`[data-index="${i}"]`);
                    if (element) {
                        element.innerHTML = '';
                        
                        if (this.board[i] !== null) {
                            const stone = document.createElement('div');
                            stone.className = `stone ${this.board[i]}`;
                            element.appendChild(stone);
                        }
                    }
                }

                // ì •ë³´ ì—…ë°ì´íŠ¸
                document.getElementById('playerStones').textContent = this.playerStones;
                document.getElementById('computerStones').textContent = this.computerStones;

                const { playerScore, computerScore } = this.calculateScore(false);
                document.getElementById('playerTerritory').textContent = playerScore;
                document.getElementById('computerTerritory').textContent = computerScore;

                // ìƒíƒœ í‘œì‹œ
                if (!this.gameEnded) {
                    const statusText = this.currentPlayer === 'player' ? 
                        'ë‹¹ì‹ ì˜ ì°¨ë¡€ì…ë‹ˆë‹¤ (íŒŒë€ìƒ‰ ëŒ)' : 
                        'ì»´í“¨í„°ê°€ ìƒê° ì¤‘ì…ë‹ˆë‹¤...';
                    document.getElementById('gameStatus').textContent = statusText;
                }

                // ë²„íŠ¼ ìƒíƒœ
                const passBtn = document.getElementById('passBtn');
                if (passBtn) {
                    passBtn.disabled = this.currentPlayer !== 'player' || this.gameEnded;
                }
            }
        }
    </script>
</body>
</html>
